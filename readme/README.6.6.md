# Домашнее задание к занятию "6.4. PostgreSQL"

## 1. Задача 1

Перед выполнением задания ознакомьтесь с документацией по администрированию MongoDB.

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её
нужно прервать.

Вы как инженер поддержки решили произвести данную операцию:

- напишите список операций, которые вы будете производить для остановки запроса пользователя
- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

Ответ:

Поиск операции по времени, 180 секунд [db.currentOp()](https://www.mongodb.com/docs/manual/reference/method/db.currentOp/)
```shell
db.currentOp(
   {
     "active" : true,
     "secs_running" : { "$gt" : 180 },
     "ns" : /^db1\./
   }
)
```
Завершить операцию в соответствии с идентификатором операции [db.killOp()](https://www.mongodb.com/docs/manual/reference/method/db.killOp/)
```shell
db.killOp(opid)
```
Прежде всего надо разобраться проблема в настройках или конфигурации БД. Если проблема в самом запросе, это больше
вопрос к разработчику.
Если же проблема например в том, что слишком много записей, то наверное помогло бы создание индекса.
В общем надо сначала выяснить в чем конкретно проблема.

## 2. Задача 2

Перед выполнением задания познакомьтесь с документацией по Redis latency troobleshooting.

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. Причем отношение
количества записанных key-value значений к количеству истёкших значений есть величина постоянная и увеличивается
пропорционально количеству реплик сервиса.

При масштабировании сервиса до N реплик вы увидели, что:

- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи
- Как вы думаете, в чем может быть проблема?

Ответ:
```
 Похоже на проблему задержка, вызываемой истечением срока действия. Согласно документации:
 
"В основном это означает, что если в базе данных есть много-много ключей, срок действия которых истекает в одну
и ту же секунду, и они составляют не менее 25% текущей совокупности ключей с установленным сроком действия,
Redis может заблокировать, чтобы получить процент ключей, срок действия которых уже истек, ниже 25%.

Такой подход необходим, чтобы не использовать слишком много памяти для ключей, срок действия которых уже истек,
и обычно абсолютно безвреден, так как странно, что срок действия большого количества ключей истекает в одну и ту же
секунду, но не исключено, что пользователь активно использовал EXPIREAT с тем же временем Unix.

Короче говоря: имейте в виду, что многие ключи, срок действия которых истекает в один и тот же момент, могут быть
источником задержки."
```

## 3. Задача 3

Перед выполнением задания познакомьтесь с документацией по Common Mysql errors.

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```
Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения данной проблемы вы можете предложить?

Ответ:
```
Обычно это указывает на проблемы с подключением к сети, и в первую очередь следует проверить состояние вашей сети.

Может надо изменить настройки таймаута для запросов, такие как connect_timeout и net_read_timeout.
Параметры wait_timeout и interactive_timeout не должны вызывать никаких проблем, потому что они обычно имеют
значение по умолчанию 28800 секунд.

Другая возможность — это большой запрос. Я полагаю, что имеется в виду - большой результат запроса. Предпологается,
что нужно увеличить «max_allowed_packet» на сервере.
```
## 4. Задача 4

Перед выполнением задания ознакомтесь со статьей Common PostgreSQL errors из блога Percona.

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:
```
postmaster invoked oom-killer
```
Как вы думаете, что происходит?

Как бы вы решили данную проблему?

Ответ:
```
Postgre убит oom-killer, из-за нехватки оперативной памяти. 

Собственно надо опять же смотреть в чем причина того, что отжирается память.

Может это проблемы настройки самой операционки.
Unix-подобные операционные системы применяют различные ограничения ресурсов, которые могут мешать работе сервера
PostgreSQL . Особое значение имеют ограничения на количество процессов на пользователя, количество открытых файлов на
процесс и объем памяти, доступный каждому процессу. Каждый из них имеет «жесткий» и «мягкий» предел. Мягкий предел —
это то, что действительно имеет значение, но пользователь может изменить его до жесткого предела. Жесткий предел
может быть изменен только пользователем root.

Может память отъедает какой-либо параллельный процесс.

Возможно надо менять конфигурации PostgreSQL, а именно параметры влияющие на использование общей памяти, такие как:
- max_connections
- max_prepared_transactions
- shared_buffers
- wal_buffers
- max_fsm_relations
- max_fsm_pages
```

